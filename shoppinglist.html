<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dynamic Map Shopping List</title>
<style>
  body, html {
    margin: 0;
    height: 100%;
    overflow: hidden;
    font-family: sans-serif;
  }
  .board-area {
    width: 100%;
    height: 100%;
    overflow: auto;
    background: #f6f7fb;
    position: relative;
  }
  #board {
    background: white;
    background-image:
      linear-gradient(to right, rgba(0,0,0,0.04) 1px, transparent 1px),
      linear-gradient(to bottom, rgba(0,0,0,0.04) 1px, transparent 1px);
    background-size: 20px 20px;
    position: relative;
    min-width: 100%;
    min-height: 100%;
  }
  .rect {
    position: absolute;
    background: rgba(255,255,255,0.95);
    border: 1px solid #ccc;
    border-radius: 12px;
    box-sizing: border-box;
    padding: 4px 8px 24px 8px;
    transition: border-color 0.3s ease;
    user-select: none;

min-width: 160px;
min-height: 260px;

box-shadow: 2px 2px 12px rgba(0,0,0,0.1);
  }
  .rect.active {
    border-color: #007bff;
  }
  .title {
    display: flex;
    align-items: center;
    margin-bottom: 6px;
    user-select: text;
  }
  .title span {
    flex-grow: 1;
    font-weight: bold;
  }
  .title input[type=text] {
    font-weight: bold;
    font-size: 1em;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 2px 4px;
    outline: none;
    width: 100%;
    box-sizing: border-box;
  }
  .title input[type=text]:focus {
    border-color: #007bff;
    background: #e7f1ff;
  }
  .title .edit-btn {
    cursor: pointer;
    margin-right: 32px;
    color: #007bff;
    font-weight: bold;
    user-select: none;
  }
  ul {
    list-style: none;
    padding: 0;
    margin: 20px 0 60px 0;
    max-height: -webkit-fill-available;
    overflow-y: auto;
  }
  ul li {
    display: flex;
    align-items: center;
    margin-bottom: 4px;
  }
  ul li input[type=checkbox] {
    margin-right: 6px;
    cursor: pointer;
  }
  ul li input[type=text] {
    flex-grow: 1;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 2px 4px;
    outline: none;
    background: white;
    user-select: text;
  }
  ul li input[type=text]:focus {
    border-color: #007bff;
    background: #e7f1ff;
  }
  ul li.checked input[type=text] {
    color: #999;
    text-decoration: line-through;
  }
  .resize-handle {
    width: 8px;
    height: 8px;
    background: #007bff;
    position: absolute;
    right: 6px;
    bottom: 6px;
    cursor: se-resize;
    border-radius: 4px;
  }
  .btn-add-list {
    position: absolute;
    bottom: 6px;
    left: 6px;
    width: 24px;
    height: 24px;
    background: #007bff;
    border-radius: 50%;
    color: white;
    font-weight: bold;
    font-size: 18px;
    line-height: 24px;
    text-align: center;
    cursor: pointer;
    user-select: none;
    box-shadow: 0 0 6px rgba(0,0,0,0.15);
  }
  .btn-delete-area {
    position: absolute;
    top: 6px;
    right: 6px;
    width: 22px;
    height: 22px;
    background: red;
    border-radius: 50%;
    color: white;
    font-weight: bold;
    font-size: 16px;
    line-height: 22px;
    text-align: center;
    cursor: pointer;
    user-select: none;
    box-shadow: 0 0 6px rgba(0,0,0,0.15);
  }
  #btnNew {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 52px;
    height: 52px;
    background: #007bff;
    border-radius: 50%;
    color: white;
    font-weight: bold;
    font-size: 36px;
    line-height: 52px;
    text-align: center;
    cursor: pointer;
    user-select: none;
    border: none;
    box-shadow: 0 4px 8px rgba(0,0,0,0.25);
  }
  #minimap {
    position: fixed;
    bottom: 20px;
    left: 20px;
    width: 160px;
    height: 120px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 12px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    z-index: 1000;
  }
  #exportImportWrapper {
    position: fixed;
    top: 20px;
    right: 20px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 0 8px rgba(0,0,0,0.1);
    padding: 12px 12px;
    z-index: 1001;
    display: flex;
    gap: 10px;
  }
  button.export-btn, button.import-btn {
    background: #007bff;
    color: white;
    border: none;
    border-radius: 6px;
    padding: 6px 12px;
    cursor: pointer;
    user-select: none;
    font-size: 14px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.15);
  }
  button.export-btn:hover, button.import-btn:hover {
    background: #0056b3;
  }
</style>
</head>
<body>
<div class="board-area">
  <div id="board">
    <button id="btnNew" title="Add Area">+</button>
  </div>
</div>

<div id="exportImportWrapper">
  <button class="export-btn" title="Export Map">Export</button>
  <button class="import-btn" title="Import Map">Import</button>
  <input type="file" id="importFile" style="display:none" accept="application/json" />
</div>

<canvas id="minimap" width="160" height="120"></canvas>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const board = document.getElementById('board');
  const btnNew = document.getElementById('btnNew');
  const btnExport = document.querySelector('.export-btn');
  const btnImport = document.querySelector('.import-btn');
  const importFile = document.getElementById('importFile');
  const minimapCanvas = document.getElementById('minimap');
  const ctx = minimapCanvas.getContext('2d');

  let areas = [];
  let activeArea = null;

  // Utility: snap to 20x20 grid
  function snapToGrid(value, gridSize = 20) {
    return Math.round(value / gridSize) * gridSize;
  }

  // Add a new area
  function addArea(x = 20, y = 20, title = 'Area', items = []) {
    const area = document.createElement('div');
    area.className = 'rect';
    area.style.left = snapToGrid(x) + 'px';
    area.style.top = snapToGrid(y) + 'px';
    area.style.width = '120px';
    area.style.height = '80px';
    area.setAttribute('tabindex', 0);

    // Title bar with editable span + pencil icon
    const titleBar = document.createElement('div');
    titleBar.className = 'title';

    const titleSpan = document.createElement('span');
    titleSpan.textContent = title;
    titleBar.appendChild(titleSpan);

    const editBtn = document.createElement('div');
    editBtn.className = 'edit-btn';
    editBtn.textContent = '✎';
    titleBar.appendChild(editBtn);

    // Editable input (hidden initially)
    const titleInput = document.createElement('input');
    titleInput.type = 'text';
    titleInput.value = title;
    titleInput.style.display = 'none';
    titleBar.appendChild(titleInput);

    area.appendChild(titleBar);

    // List container
    const ul = document.createElement('ul');
    area.appendChild(ul);

    // Add items if any
    items.forEach(({text, checked}) => {
      const li = createListItem(text, checked);
      ul.appendChild(li);
    });

    // Add List button (blue circle with +)
    const btnAddList = document.createElement('div');
    btnAddList.className = 'btn-add-list';
    btnAddList.textContent = '+';
    area.appendChild(btnAddList);

    // Delete area button (red circle with ×)
    const btnDelete = document.createElement('div');
    btnDelete.className = 'btn-delete-area';
    btnDelete.textContent = '×';
    area.appendChild(btnDelete);

    // Resize handle
    const resizeHandle = document.createElement('div');
    resizeHandle.className = 'resize-handle';
    area.appendChild(resizeHandle);

    board.appendChild(area);
    areas.push(area);

    // Activate area on click
    area.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      setActiveArea(area);
    });

    // Activate on touch start (mobile)
    area.addEventListener('touchstart', (e) => {
      e.stopPropagation();
      setActiveArea(area);
    }, {passive:true});

    // Title editing toggles
    editBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      titleSpan.style.display = 'none';
      editBtn.style.display = 'none';
      titleInput.style.display = 'inline-block';
      titleInput.focus();
      titleInput.select();
    });

    titleInput.addEventListener('blur', () => {
      titleSpan.textContent = titleInput.value.trim() || 'Area';
      titleSpan.style.display = 'inline';
      editBtn.style.display = 'inline-block';
      titleInput.style.display = 'none';
    });

    titleInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        titleInput.blur();
      }
    });

    // Add list item on Add List button click
    btnAddList.addEventListener('click', (e) => {
      e.stopPropagation();
      const li = createListItem('', false);
      ul.appendChild(li);
      li.querySelector('input[type=text]').focus();
      updateMinimap();
    });

    // Delete area
    btnDelete.addEventListener('click', (e) => {
      e.stopPropagation();
      removeArea(area);
    });

    // Enable resizing only if area is active
    enableResizing(area, resizeHandle);

    // Enable moving
    enableMoving(area);

    // Update board size to fit
    expandBoardToFit(area);
    updateMinimap();

    return area;
  }

  // Create a list item <li> with checkbox + editable text input
  function createListItem(text = '', checked = false) {
    const li = document.createElement('li');

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = checked;

    const input = document.createElement('input');
    input.type = 'text';
    input.value = text;

    if (checked) li.classList.add('checked');

    // Toggle checked style on checkbox change
    checkbox.addEventListener('change', () => {
      if (checkbox.checked) {
        li.classList.add('checked');
      } else {
        li.classList.remove('checked');
      }
      updateMinimap();
    });

    // Focus input on click for re-edit
    input.addEventListener('click', (e) => {
      e.stopPropagation();
      input.focus();
    });

    // Enter creates new list item below
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const ul = li.parentElement;
        const newLi = createListItem('', false);
        ul.insertBefore(newLi, li.nextSibling);
        newLi.querySelector('input[type=text]').focus();
        updateMinimap();
      }
    });

    li.appendChild(checkbox);
    li.appendChild(input);

    return li;
  }

  // Set active area with visual border and unselect others
  function setActiveArea(area) {
    if (activeArea === area) return;
    if (activeArea) {
      activeArea.classList.remove('active');
    }
    activeArea = area;
    if (activeArea) {
      activeArea.classList.add('active');
    }
  }

  // Remove an area from board and array
  function removeArea(area) {
    board.removeChild(area);
    areas = areas.filter(a => a !== area);
    if (activeArea === area) {
      activeArea = null;
    }
    updateMinimap();
  }

  // Enable dragging/moving the area
  function enableMoving(area) {
    let isMoving = false;
    let startX, startY, origX, origY;

    area.addEventListener('mousedown', (e) => {
      if (!canMoveArea()) return;
      if (activeArea !== area) return; // Only move active area on desktop

      isMoving = true;
      startX = e.pageX;
      startY = e.pageY;
      origX = area.offsetLeft;
      origY = area.offsetTop;
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isMoving) return;
      let newX = origX + (e.pageX - startX);
      let newY = origY + (e.pageY - startY);
      newX = Math.max(0, snapToGrid(newX));
      newY = Math.max(0, snapToGrid(newY));
      area.style.left = newX + 'px';
      area.style.top = newY + 'px';
      expandBoardToFit(area);
      updateMinimap();
    });

    document.addEventListener('mouseup', () => {
      isMoving = false;
    });

    // Touch support
    area.addEventListener('touchstart', (e) => {
      if (!canMoveArea()) return;
      if (activeArea !== area) return;

      const touch = e.touches[0];
      isMoving = true;
      startX = touch.pageX;
      startY = touch.pageY;
      origX = area.offsetLeft;
      origY = area.offsetTop;
    }, {passive:true});

    document.addEventListener('touchmove', (e) => {
      if (!isMoving) return;
      const touch = e.touches[0];
      let newX = origX + (touch.pageX - startX);
      let newY = origY + (touch.pageY - startY);
      newX = Math.max(0, snapToGrid(newX));
      newY = Math.max(0, snapToGrid(newY));
      area.style.left = newX + 'px';
      area.style.top = newY + 'px';
      expandBoardToFit(area);
      updateMinimap();
    }, {passive:true});

    document.addEventListener('touchend', () => {
      isMoving = false;
    });
  }

  // Determine if area can be moved according to device & active
  function canMoveArea() {
    const isMobile = /Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    if (isMobile) {
      return true; // on mobile/tablet, only move if active (checked above)
    } else {
      return true; // on desktop, always allow moving (no activeArea check in listener)
    }
  }

  // Enable resizing area using the resize handle
  function enableResizing(area, handle) {
    let isResizing = false;

    handle.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      isResizing = true;
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;
      let newWidth = e.pageX - area.offsetLeft + board.scrollLeft;
      let newHeight = e.pageY - area.offsetTop + board.scrollTop;
      newWidth = Math.max(40, snapToGrid(newWidth));
      newHeight = Math.max(40, snapToGrid(newHeight));
      area.style.width = newWidth + 'px';
      area.style.height = newHeight + 'px';
      expandBoardToFit(area);
      updateMinimap();
    });

    document.addEventListener('mouseup', () => {
      isResizing = false;
    });

    // Touch support
    handle.addEventListener('touchstart', (e) => {
      e.stopPropagation();
      isResizing = true;
    }, {passive:true});

    document.addEventListener('touchmove', (e) => {
      if (!isResizing) return;
      const touch = e.touches[0];
      let newWidth = touch.pageX - area.offsetLeft + board.scrollLeft;
      let newHeight = touch.pageY - area.offsetTop + board.scrollTop;
      newWidth = Math.max(40, snapToGrid(newWidth));
      newHeight = Math.max(40, snapToGrid(newHeight));
      area.style.width = newWidth + 'px';
      area.style.height = newHeight + 'px';
      expandBoardToFit(area);
      updateMinimap();
    }, {passive:true});

    document.addEventListener('touchend', () => {
      isResizing = false;
    });
  }

  // Expand board min width/height to fit an area fully
  function expandBoardToFit(area) {
    const right = area.offsetLeft + area.offsetWidth;
    const bottom = area.offsetTop + area.offsetHeight;

    if (board.scrollWidth < right) {
      board.style.minWidth = right + 40 + 'px';
    }
    if (board.scrollHeight < bottom) {
      board.style.minHeight = bottom + 40 + 'px';
    }
  }

  // Clear active area if click outside any area
  board.addEventListener('mousedown', (e) => {
    if (e.target === board) {
      if (activeArea) {
        activeArea.classList.remove('active');
        activeArea = null;
      }
    }
  });

  board.addEventListener('touchstart', (e) => {
    if (e.target === board) {
      if (activeArea) {
        activeArea.classList.remove('active');
        activeArea = null;
      }
    }
  }, {passive:true});

  // Button new area
  btnNew.addEventListener('click', () => {
    addArea(20, 20, 'Area', []);
  });

  // Export button - downloads JSON file
  btnExport.addEventListener('click', () => {
    const data = areas.map(area => {
      const title = area.querySelector('.title span')?.textContent || 'Area';
      const pos = { left: area.offsetLeft, top: area.offsetTop };
      const size = { width: area.offsetWidth, height: area.offsetHeight };
      const items = [...area.querySelectorAll('ul li')].map(li => {
        return {
          text: li.querySelector('input[type=text]').value,
          checked: li.querySelector('input[type=checkbox]').checked
        };
      });
      return { title, pos, size, items };
    });
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: "application/json" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = 'shopping_map.json';
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 0);
  });

  // Import button triggers file input
  btnImport.addEventListener('click', () => {
    importFile.click();
  });

  // On file selected for import
  importFile.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const json = JSON.parse(event.target.result);
        loadFromData(json);
      } catch(err) {
        alert('Invalid JSON file.');
      }
    };
    reader.readAsText(file);
    // Reset input to allow same file again if needed
    importFile.value = '';
  });

  // Load from JSON data (array of areas)
  function loadFromData(data) {
    // Clear current
    areas.forEach(a => board.removeChild(a));
    areas = [];
    activeArea = null;

    data.forEach(({title, pos, size, items}) => {
      const area = addArea(pos.left, pos.top, title, items);
      area.style.width = size.width + 'px';
      area.style.height = size.height + 'px';
      expandBoardToFit(area);
    });
    updateMinimap();
  }

  // Minimap drawing function
  function updateMinimap() {
    const cw = minimapCanvas.width;
    const ch = minimapCanvas.height;
    ctx.clearRect(0, 0, cw, ch);

    // Get board bounding box
    const boardRect = board.getBoundingClientRect();
    const boardWidth = Math.max(board.scrollWidth, boardRect.width);
    const boardHeight = Math.max(board.scrollHeight, boardRect.height);

    // Calculate scale to fit board inside minimap
    const scaleX = cw / boardWidth;
    const scaleY = ch / boardHeight;
    const scale = Math.min(scaleX, scaleY);

    // Draw background grid on minimap
    ctx.fillStyle = '#f6f7fb';
    ctx.fillRect(0, 0, cw, ch);

    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 0.5;
    const gridSize = 20 * scale;
    for (let x = 0; x <= cw; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, ch);
      ctx.stroke();
    }
    for (let y = 0; y <= ch; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(cw, y);
      ctx.stroke();
    }

    // Draw all areas scaled down
    areas.forEach(area => {
      const x = area.offsetLeft * scale;
      const y = area.offsetTop * scale;
      const w = area.offsetWidth * scale;
      const h = area.offsetHeight * scale;

      ctx.fillStyle = 'rgba(0,123,255,0.3)';
      ctx.strokeStyle = 'rgba(0,123,255,0.7)';
      ctx.lineWidth = 1;

      ctx.fillRect(x, y, w, h);
      ctx.strokeRect(x, y, w, h);

      // Draw active area with darker border
      if (area === activeArea) {
        ctx.strokeStyle = '#004085';
        ctx.lineWidth = 2;
        ctx.strokeRect(x+2, y+2, w-4, h-4);
      }
    });
  }

  // Update minimap on scroll and resize
  document.querySelector('.board-area').addEventListener('scroll', updateMinimap);
  window.addEventListener('resize', updateMinimap);

  // Start with one area
  addArea(40, 40, 'Area', []);

  // Initial minimap draw
  updateMinimap();

});
</script>
</body>
</html>
