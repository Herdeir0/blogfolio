<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Map Shopping List — Single File</title>
  <style>
    :root{--bg:#f6f7fb;--accent:#0b74ff;--muted:#6b7280}
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:#111}
    .board-wrap{height:100vh;padding:0;margin:0;box-sizing:border-box}
    .board-area{height:100%;position:relative;overflow:auto}

    /* very large scrollable board to simulate "infinite" space */
    #board{width:8000px;height:8000px;background:#fff;position:relative;margin:0;box-shadow:inset 0 0 0 1px rgba(15,23,42,0.03);
      background-image:linear-gradient(to right, rgba(0,0,0,0.04) 1px, transparent 1px),
                       linear-gradient(to bottom, rgba(0,0,0,0.04) 1px, transparent 1px);
      background-size:20px 20px;
    }

    .top-left-btn{position:absolute;top:20px;left:20px;z-index:20}
    button{background:#111;color:#fff;border:0;padding:8px 10px;border-radius:8px;font-size:13px;cursor:pointer}

    .rect{position:absolute;border:2px dashed rgba(11,20,50,0.12);background:linear-gradient(180deg, rgba(255,255,255,0.95), rgba(250,250,255,0.95));border-radius:8px;box-sizing:border-box;overflow:hidden;display:flex;flex-direction:column}
    .rect .title{background:rgba(250,250,255,0.95);padding:6px 8px;font-weight:600;border-bottom:1px solid rgba(11,20,50,0.03);display:flex;align-items:center;justify-content:space-between;gap:6px}
    .rect .title .label{flex:1;cursor:default}
    .rect .title input{flex:1;border:1px solid #e2e8f0;padding:4px;border-radius:4px}
    .rect .title .edit-btn{cursor:pointer;font-size:14px;padding:4px}
    .rect .delete-btn{width:20px;height:20px;background:red;border-radius:50%;display:flex;align-items:center;justify-content:center;color:white;font-weight:bold;cursor:pointer;font-size:14px;line-height:14px}
    .rect .content{padding:8px;flex:1;overflow:auto}
    .resize-handle{width:12px;height:12px;background:var(--accent);position:absolute;right:6px;bottom:6px;border-radius:3px;cursor:se-resize;z-index:12}
    .selected{box-shadow:0 6px 18px rgba(11,20,50,0.12);border-style:solid;border-color:var(--accent)}

    .list{list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:6px}
    .list li{display:flex;gap:8px;align-items:center}
    .list li input[type="text"]{flex:1;border:1px solid #ccc;border-radius:4px;padding:4px;background:#fff}
    .add-list-btn{margin:6px;padding:6px;font-size:12px;background:var(--accent);border-radius:6px}

    /* Make interactive elements visually on top */
    .rect .title,.rect .delete-btn,.rect .edit-btn,.rect .add-list-btn{z-index:10}
  </style>
</head>
<body>
  <div class="board-wrap">
    <div class="board-area">
      <div id="board">
        <button class="top-left-btn" id="btnNew">+ Add Area</button>
      </div>
    </div>
  </div>

  <template id="rect-template">
    <div class="rect">
      <div class="title">
        <span class="label">Area</span>
        <span class="edit-btn" title="Edit name">✏️</span>
        <div class="delete-btn" title="Delete">×</div>
      </div>
      <div class="content"></div>
      <button class="add-list-btn">+ Add list</button>
      <div class="resize-handle" title="Resize"></div>
    </div>
  </template>

  <script>
    const board = document.getElementById('board');
    const tpl = document.getElementById('rect-template');
    let state = {areas:[], selected:null};
    const uid = ()=>Math.random().toString(36).slice(2,9);
    const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
    const snap20 = v => Math.round(v/20)*20;

    function getContainer(){ return board.parentElement; }

    function createArea(x, y, w=240, h=160, title='Area'){
      const container = getContainer();
      const cx = (typeof x === 'number') ? x : container.scrollLeft + Math.max((container.clientWidth - w)/2, 0);
      const cy = (typeof y === 'number') ? y : container.scrollTop + Math.max((container.clientHeight - h)/2, 0);
      const id = uid();
      const area = {id, x: snap20(cx), y: snap20(cy), w: snap20(w), h: snap20(h), title, items: []};
      state.areas.push(area);
      renderArea(area);
      selectArea(id);
      return area;
    }

    function renderAll(){ board.querySelectorAll('.rect').forEach(n=>n.remove()); state.areas.forEach(renderArea); }

    function renderArea(area){
      const old = board.querySelector(`[data-id="${area.id}"]`);
      if(old) old.remove();

      const node = tpl.content.firstElementChild.cloneNode(true);
      node.style.left = area.x + 'px';
      node.style.top = area.y + 'px';
      node.style.width = area.w + 'px';
      node.style.height = area.h + 'px';
      node.dataset.id = area.id;

      // title
      const label = node.querySelector('.label');
      label.textContent = area.title;

      const editBtn = node.querySelector('.edit-btn');
      editBtn.addEventListener('click', (e)=>{ e.stopPropagation(); startEditTitle(area, node); });

      const deleteBtn = node.querySelector('.delete-btn');
      deleteBtn.addEventListener('click', (e)=>{ e.stopPropagation(); state.areas = state.areas.filter(a => a.id !== area.id); if(state.selected === area.id) state.selected = null; renderAll(); });

      // dragging (pointer + touch fallback)
      node.addEventListener('pointerdown', (e) => {
        if (e.target.closest('button, input, textarea, .edit-btn, .delete-btn, .add-list-btn')) return;
        if (e.target.classList.contains('resize-handle') || e.button !== 0) return;
        selectArea(area.id);
        startDragPointer(node, area, e);
      });

      node.addEventListener('touchstart', (e)=>{
        if (e.target.closest('button, input, textarea, .edit-btn, .delete-btn, .add-list-btn')) return;
        if (e.target.classList.contains('resize-handle')) return;
        if (e.touches && e.touches.length>1) return;
        selectArea(area.id);
        startDragTouch(node, area, e);
      }, {passive:false});

      // resize (pointer + touch)
      const handle = node.querySelector('.resize-handle');
      handle.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); startResizePointer(node, area, e); });
      handle.addEventListener('touchstart', (e)=>{ e.stopPropagation(); if(e.touches && e.touches.length>1) return; startResizeTouch(node, area, e); }, {passive:false});

      // content / lists
      const content = node.querySelector('.content');
      content.innerHTML = '';
      const ul = document.createElement('ul'); ul.className = 'list';
      (area.items || []).forEach((it, i)=> ul.appendChild(makeListItem(area, i)));
      content.appendChild(ul);

      // add-list button
      const addBtn = node.querySelector('.add-list-btn');
      addBtn.addEventListener('click', (e)=>{ e.stopPropagation(); area.items.push({text:'', checked:false}); renderArea(area); });

      board.appendChild(node);
      refreshSelectionStyles();
    }

    function startEditTitle(area, node){
      const titleEl = node.querySelector('.title');
      const oldLabel = titleEl.querySelector('.label');
      const input = document.createElement('input');
      input.value = area.title; input.autofocus = true;
      input.addEventListener('blur', finish);
      input.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') finish(); });
      titleEl.insertBefore(input, oldLabel);
      titleEl.removeChild(oldLabel);
      input.select();
      function finish(){ area.title = input.value || 'Area'; renderArea(area); }
    }

    function makeListItem(area, index){
      const item = area.items[index];
      const li = document.createElement('li');
      const cb = document.createElement('input'); cb.type = 'checkbox'; cb.checked = !!item.checked; cb.addEventListener('change', ()=> item.checked = cb.checked);
      const txt = document.createElement('input'); txt.type = 'text'; txt.value = item.text || ''; txt.addEventListener('input', ()=> item.text = txt.value);
      li.appendChild(cb); li.appendChild(txt);
      return li;
    }

    function selectArea(id){ state.selected = id; refreshSelectionStyles(); }
    function refreshSelectionStyles(){ board.querySelectorAll('.rect').forEach(el => el.classList.toggle('selected', el.dataset.id === state.selected)); }

    // pointer-based drag (works on desktop and modern mobile browsers)
    function startDragPointer(node, area, e){
      e.preventDefault();
      try{ node.setPointerCapture(e.pointerId); }catch(err){}
      const startX = e.clientX, startY = e.clientY, baseX = area.x, baseY = area.y;
      function move(ev){
        const dx = snap20(baseX + (ev.clientX - startX));
        const dy = snap20(baseY + (ev.clientY - startY));
        area.x = clamp(dx, 0, board.clientWidth - area.w);
        area.y = clamp(dy, 0, board.clientHeight - area.h);
        node.style.left = area.x + 'px'; node.style.top = area.y + 'px';
      }
      function up(ev){
        try{ node.releasePointerCapture(e.pointerId); }catch(err){}
        document.removeEventListener('pointermove', move);
        document.removeEventListener('pointerup', up);
      }
      document.addEventListener('pointermove', move);
      document.addEventListener('pointerup', up);
    }

    // touch-based drag fallback for older browsers that may not support pointer events
    function startDragTouch(node, area, e){
      e.preventDefault();
      const touch = e.touches[0];
      const startX = touch.clientX, startY = touch.clientY, baseX = area.x, baseY = area.y;
      function move(ev){ ev.preventDefault(); const t = ev.touches[0]; const dx = snap20(baseX + (t.clientX - startX)); const dy = snap20(baseY + (t.clientY - startY)); area.x = clamp(dx, 0, board.clientWidth - area.w); area.y = clamp(dy, 0, board.clientHeight - area.h); node.style.left = area.x + 'px'; node.style.top = area.y + 'px'; }
      function up(ev){ document.removeEventListener('touchmove', move, {passive:false}); document.removeEventListener('touchend', up); }
      document.addEventListener('touchmove', move, {passive:false});
      document.addEventListener('touchend', up);
    }

    // pointer-based resize
    function startResizePointer(node, area, e){
      e.preventDefault();
      try{ node.setPointerCapture(e.pointerId); }catch(err){}
      const startX = e.clientX, startY = e.clientY, baseW = area.w, baseH = area.h;
      function move(ev){
        const nw = snap20(baseW + (ev.clientX - startX));
        const nh = snap20(baseH + (ev.clientY - startY));
        area.w = clamp(nw, 80, board.clientWidth - area.x);
        area.h = clamp(nh, 60, board.clientHeight - area.y);
        node.style.width = area.w + 'px'; node.style.height = area.h + 'px';
      }
      function up(ev){
        try{ node.releasePointerCapture(e.pointerId); }catch(err){}
        document.removeEventListener('pointermove', move);
        document.removeEventListener('pointerup', up);
      }
      document.addEventListener('pointermove', move);
      document.addEventListener('pointerup', up);
    }

    // touch-based resize fallback
    function startResizeTouch(node, area, e){
      e.preventDefault();
      const touch = e.touches[0];
      const startX = touch.clientX, startY = touch.clientY, baseW = area.w, baseH = area.h;
      function move(ev){ ev.preventDefault(); const t = ev.touches[0]; const nw = snap20(baseW + (t.clientX - startX)); const nh = snap20(baseH + (t.clientY - startY)); area.w = clamp(nw, 80, board.clientWidth - area.x); area.h = clamp(nh, 60, board.clientHeight - area.y); node.style.width = area.w + 'px'; node.style.height = area.h + 'px'; }
      function up(ev){ document.removeEventListener('touchmove', move, {passive:false}); document.removeEventListener('touchend', up); }
      document.addEventListener('touchmove', move, {passive:false});
      document.addEventListener('touchend', up);
    }

    // clicking empty board deselects
    board.addEventListener('pointerdown', (e)=>{ if(e.target === board) { state.selected = null; refreshSelectionStyles(); } });

    // double click to add area at mouse location
    board.addEventListener('dblclick', (e)=>{
      const rect = board.getBoundingClientRect();
      const container = getContainer();
      const x = container.scrollLeft + (e.clientX - rect.left);
      const y = container.scrollTop + (e.clientY - rect.top);
      createArea(snap20(x), snap20(y));
    });

    // add area button inside board
    document.getElementById('btnNew').addEventListener('click', (e)=>{ e.stopPropagation(); createArea(); });

    // initial demo areas
    function init(){ createArea(80,80,280,180,'Produce'); createArea(420,80,260,180,'Dairy'); }
    init();
  </script>
</body>
</html>
